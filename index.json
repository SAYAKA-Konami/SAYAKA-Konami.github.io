[{"categories":null,"content":"借助Spring实现责任链 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:0:0","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"需求 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:1:0","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"对请求注册的数据做一些前置处理 这个需求很常见。而且Spring也提供了相应的注解来解决此类问题。但注解通常只负责解决格式上的问题。像不允许重名、不允许重复注册这类需要借助数据库来实现的功能就只能在代码层面来解决了。 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:1:1","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"解耦 设计模式的出现很大程度上都是为了解耦。 面向对象编程提倡的一个关键的点是开闭原则。即对修改关闭，但对扩展开放（emmmm有些机翻的味道，大概知道什么意思就行）。 所以在数据的前置校验中，我不希望把逻辑直接添加到注册的功能中。更希望的是用一行代码来执行前置处理。把前置处理的逻辑都放在幕后。 最后的代码长这样： public CommonResult\u003cString\u003e register(UserDto userDto){ CommonResult\u003cString\u003e handle = handleRegister.handle(userDto); if (handle != null) return handle; // 省略注册的逻辑实现 } ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:2:0","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"面向接口编程 其实初学的时候完全不能理解为什么要这么做，感觉很多此一举。根据后来的经验发现，觉得多此一举而又被业界承认的观点往往是为了方便某一场景。 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:3:0","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"你可以把它看成一个链表 事实上责任链这个名字也暗含着这层意思。数据从链的这一头出发，途径各个过滤器。就好像在遍历链表一样。 中途如果不符合某个过滤器的“心思”，那么就会遭受它的“制裁”。或是对被过滤的东西做修剪，最糟糕的情况下会直接将其丢弃。就像流水线上的空盒子会被检测机器或人工丢弃一样。 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:3:1","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"把它当成链表来实现 我们可以定义一个抽象类。 public abstract class HandleRegister { protected HandleRegister next; public abstract CommonResult\u003cString\u003e handle(UserDto userDto); public void setNext(HandleRegister handleRegister){ next = handleRegister; } public CommonResult\u003cString\u003e pass(HandleRegister handleRegister, UserDto userDto){ if (handleRegister == null) return null; else return handleRegister.handle(userDto); } } 这个抽象类定义了（请记住这里是定义，毕竟抽象类就是用来定义或者搭建一个类的基础骨架的。至于为什么还请继续看下去。）一个next字段。它的意思是指当前过滤器的下一个过滤器。 作为一个过滤器，他们都有一个名为“过滤”的举动。只是不同的过滤器的执行逻辑不同。所以我们把handle的实现交给子类。 你可能会很好奇pass(HandleRegister handleRegister, UserDto userDto)方法是用来干什么的。是的，这就是为什么我不直接采用接口来约定“过滤”这一举动的原因。 假设没有这个方法，那每一个子类在执行完过滤逻辑之后应当怎么做呢？ // 执行过滤逻辑 doFilter(); // 假设被过滤的数据安全的度过了这个过滤器 // 如果这个过滤器是整条链上的最后一个节点，那么证明被过滤的数据安全的度过了审核 if (next == null) return true; // 不然的话就交给下一个过滤器 else next.handle(data); 可以看到，每个执行器执行过滤之后都要做相同的“动作”——把待过滤的东西交给下一个。 既然它们这个动作都一样，那我们就可以将这个动作抽象出来。把它看成过滤器应当具有的一个“行为”。 所以就有了上面代码中的pass(HandleRegister handleRegister, UserDto userDto)。它其实就是这个传递行为的定义！ ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:3:2","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"子类会长什么样？ 让我们来看看校验重复昵称的过滤器： @Component public class CheckName extends HandleRegister { @Autowired UserDao userDao; @Override public CommonResult\u003cString\u003e handle(UserDto userDto) { int count = userDao.countByName(userDto.getName()); if (count == 1) return CommonResult.failed(REPEAT_NAME); else return pass(next, userDto); } } 需要强调的是，每个子类我们都会将其放置到IOC容器中。毕竟本章的标题是“借助Spring”。 可以看到，子类只需要实现“过滤”的逻辑即可。 这里不要忘记了。每个子类都还从抽象类中继承者一个next和一个setNext()方法。 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:3:3","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"怎么把它们组装起来？ 接下来就需要借助Spring的能力了。 @Configuration public class InitHandleChain { @Autowired List\u003cHandleRegister\u003e handleRegisters; @Bean(name = \"registerChain\") public HandleRegister buildFirst(){ for (int i = 0; i \u003c handleRegisters.size() - 1; i++) { handleRegisters.get(i).setNext(handleRegisters.get(i + 1)); } return handleRegisters.get(0); } } 由于子类都是继承自同一抽象类。所以它们的“类型”是一致的。我们可以借助Spring将它们一并注入到打造链条的地方。（Spring真的是一个非常好的框架！！） buildFirst的逻辑非常的简单。就是组装过滤器，让他们形成一个链条并且在最后返回链条的头指针！ ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:3:4","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"乱七八糟的看完了，好处呢？ 如果你还记得我前面说过的话的话，你应该可以发现。如果在之后的时间中你突发奇想或者被迫需要加入或删除一个过滤器的话。你完全不需要动注册方法中的代码。只需要新建一个过滤器或者删掉一个过滤器。为此你可以把你更多的精力放在过滤的逻辑上而不是重新到业务代码中阅读并定位你究竟得对代码做怎样的删除或修改。 如果你是一个规划能力较弱的人——就如同我一样。在写之前没有考虑到所有情况的话，那么你会发现开闭原则拯救了你！ 哦对了，上面的代码都是我在MCSW项目中的写的。如果你感兴趣的话，就到我主页去看看吧 ","date":"2022-11-26","objectID":"/chain-of-responsibility-pattern/:4:0","tags":null,"title":"Chain of Responsibility Pattern","uri":"/chain-of-responsibility-pattern/"},{"categories":null,"content":"MCSW--Chapter One MCSW面向的用户 我希望打造的是一个面向学校内部的讨论平台。考虑的主要因素如下： 从宏观角度出发，毕业生的去向和学校的排名是息息相关的。虽然一定程度上会局限信息的覆盖范围，但是对于在校的学生会更有参考价值。——在论文中应当采用SCAU和其他高校毕业生去向数据的横向对比。 后端服务的划分 首先需要介绍一下微服务： 根据上述微服务的特性。我暂且将 MCSW 的后端服务板块划分成了如下样式 ","date":"2022-11-25","objectID":"/checkidentify/:0:0","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"账号注册与管理 这是本章节的论述范围。 该模块具体负责的是用户的注册与权限的管理。其中最大的问题就是如何限制用户群体的“面貌”。 我的解决方案是利用学校官网的信息门户的登录功能来对用户做甄别。 下图是学校信息门户的登录界面： 由于每个学生的学号都是唯一的。所以可以在用户注册时令其提供相应的账号信息，然后把“鉴别”的任务交给学校官网提供的登录接口。 ","date":"2022-11-25","objectID":"/checkidentify/:1:0","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"利用HTTP抓包的形式查看登录信息门户所需要的参数及对应的URL 利用浏览器提供的开发者工具查看点击登录后的HTTP请求： 在上图中我们可以看到该登录接口对应的URL。 与之对应的是登录请求中携带的参数。可以看到的是密码被做了加密处理。 以下是请求所需的参数名： username password captcha warn It execution _eventId submit 为啥要在前端加密？ 我猜测应该是为了防止中间人攻击所以先做了一次加密。但是可以肯定的是，既然是在页面发送时就做了加密，那么相应的代码中就会有体现加密的过程。 返回登录页面查看页面结构： 可以看到除了浏览器渲染所需要的html文件还有几个对应的JS文件。如果你接触过计网的话应该有听过RSA ——一种非对称性加密算法。显然我们填入的密码就应当是给该JS中的函数加密之后再发送出去的。 ","date":"2022-11-25","objectID":"/checkidentify/:1:1","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"查看HTML中关于密码的加密措施 如下是 login.html 中关于密码加密的代码： $(\".btn-submit\").click(function(){ $(\"#password\").attr({maxlength:\"1000\"}); var thisPwd = document.getElementById(\"password\").value; if(thisPwd.length != 256){ setMaxDigits(131); var key = new RSAKeyPair(\"010001\", '', \"008e9fdac2a933c27a8262eb0ab8004aa74571e1e7c27beb436ce17c37df778d8861a9a2afddc04a6e80da995e34754e1e002864f2480f0471257880b55359e8232601244593333eb9f0f99b894fe13538a80bfd14aeb94bb8108959140231195a9e9f488f7d5cc72a112d6a19576cb05eaf629435538907ccc9b008d64595646d\"); var result = encryptedString(key, encodeURIComponent(thisPwd)); $(\"#password\").val(result); } }); 可以看到它调用了先前看到的RSA.js中的函数。 让我们来看一看RSA.js中的代码： function RSAKeyPair(encryptionExponent, decryptionExponent, modulus) { this.e = biFromHex(encryptionExponent); this.d = biFromHex(decryptionExponent); this.m = biFromHex(modulus); // We can do two bytes per digit, so // chunkSize = 2 * (number of digits in modulus - 1). // Since biHighIndex returns the high index, not the number of digits, 1 has // already been subtracted. this.chunkSize = 2 * biHighIndex(this.m); this.radix = 16; this.barrett = new BarrettMu(this.m); } function twoDigit(n) { return (n \u003c 10 ? \"0\" : \"\") + String(n); } function encryptedString(key, s) // Altered by Rob Saunders (rob@robsaunders.net). New routine pads the // string after it has been converted to an array. This fixes an // incompatibility with Flash MX's ActionScript. { var a = new Array(); var sl = s.length; var i = 0; while (i \u003c sl) { a[i] = s.charCodeAt(i); i++; } while (a.length % key.chunkSize != 0) { a[i++] = 0; } var al = a.length; var result = \"\"; var j, k, block; for (i = 0; i \u003c al; i += key.chunkSize) { block = new BigInt(); j = 0; for (k = i; k \u003c i + key.chunkSize; ++j) { block.digits[j] = a[k++]; block.digits[j] += a[k++] \u003c\u003c 8; } var crypt = key.barrett.powMod(block, key.e); var text = key.radix == 16 ? biToHex(crypt) : biToString(crypt, key.radix); result += text + \" \"; } return result.substring(0, result.length - 1); // Remove last space. } function decryptedString(key, s) { var blocks = s.split(\" \"); var result = \"\"; var i, j, block; for (i = 0; i \u003c blocks.length; ++i) { var bi; if (key.radix == 16) { bi = biFromHex(blocks[i]); } else { bi = biFromString(blocks[i], key.radix); } block = key.barrett.powMod(bi, key.d); for (j = 0; j \u003c= biHighIndex(block); ++j) { result += String.fromCharCode(block.digits[j] \u0026 255, block.digits[j] \u003e\u003e 8); } } // Remove trailing null, if any. if (result.charCodeAt(result.length - 1) == 0) { result = result.substring(0, result.length - 1); } return result; } 代码理解起来需要一定的密码学知识。所以我这里不打算用Java去复现这段代码。我打算在java中执行这段代码。 ","date":"2022-11-25","objectID":"/checkidentify/:1:2","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"ScriptEngine 得益于JDK内置的脚本解析器。我们直接将所需要的JS文件放置到项目下然后改写一下 login.html 中有关于加密密码的代码就可以得到同样的结果。 // 测试类 @Test public void printPasswd() { String[] path = new String[]{\"js/code.js\", \"js/RSA.js\", \"js/BigInt.js\", \"js/Barrett.js\"}; String passwd = \"wn485233\"; //用脚本解释器，使用javascript解释器 ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName(\"javascript\"); try { for (String p : path) { ClassPathResource classPathResource = new ClassPathResource(p); engine.eval(new InputStreamReader(classPathResource.getInputStream())); } // 操作js函数 passwd = (String) engine.eval(\"generatePasswd('\" + passwd + \"')\"); } catch (Exception e) { e.printStackTrace(); } System.out.println(passwd); } ","date":"2022-11-25","objectID":"/checkidentify/:1:3","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"用PostWomen模拟登录 可以看到返回的结构是浏览器渲染信息门户所需要的HTML文件。证明这种操作是可行的。 ","date":"2022-11-25","objectID":"/checkidentify/:1:4","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"踩坑 PostWomen其实是我在谷歌商店中找到的插件。也就是说它请求时会附带浏览器的一些信息。 如果在本地采用Postman或ApiPost软件提供的接口调试软件。返回的结果则是登录页面的HTML文件。 所以在代码中做登录请求时还需要将浏览器的参数user-agent附加在请求头上。 @Test public void testLogin(){ CrawlerUtil crawlerUtil = new CrawlerUtil(); // GetRSAPasswdUtil getRSAPasswdUtil = new GetRSAPasswdUtil(); Map\u003cString, Object\u003e map = crawlerUtil.getHtml(); map.put(\"username\", \"201925710123\"); map.put(\"password\", \"44cc0a532aa509c42c1a66...\"); int s = HttpRequest.post(\"https://cas.scau.edu.cn/lyuapServer/login\") .header(\"Connection\", \"keep-alive\")//头信息，多个头信息多次调用此方法即可 .header(\"Accept\", \"*/*\") .header(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\") .header(\"X-Requested-With\", \"XMLHttpRequest\") .header(\"user-agent\",\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36\") .form(map)//表单内容 .execute().getStatus(); System.out.println(s); ","date":"2022-11-25","objectID":"/checkidentify/:1:5","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"END 其实该功能最繁琐的点在于JS的逆向解密。好在登录页面附加的文件数量较少，定位加密代码的时间并没有太长。而最令我头疼的点在于抓包登录接口的相关信息。 我猜测学校的网站是前后端不分离的架构模式。所以登录成功时相应的接口返回的 HTTP Status 是302。在此之前我未曾接触过这种模式的模拟登录，而踩到的坑让我一开始误以为这种架构下的登录接口在用户登录成功与否都会返回登录界面的HTML文件。 ","date":"2022-11-25","objectID":"/checkidentify/:2:0","tags":["毕设"],"title":"MCSW-Verify user identity","uri":"/checkidentify/"},{"categories":null,"content":"PDF资源 在这个网站注册完账号后 点击蓝色位置。下载一个Tor 浏览器： ​ 在这里就可搜索相应的PDF资源！免费且可靠！ ","date":"2022-11-24","objectID":"/source/:0:0","tags":["Something fun"],"title":"Source","uri":"/source/"},{"categories":null,"content":"MCSW 想做的题目改成了：基于微信小程序的“大学生毕业去向论坛”。 ","date":"2022-11-24","objectID":"/first_post/:0:0","tags":null,"title":"毕设","uri":"/first_post/"},{"categories":null,"content":"MCSW的起因 其实一开始的题目是老师给的拼车。但是考虑到时间成本和学习成本。思索再三还是放弃了。 名字由来 M: Master。意指考研或保研继续深造的同学。 CS: Civil Servant。指进入体制内就业的同学。 W: Work。指毕业后进入社会打工、创业的同学。 ","date":"2022-11-24","objectID":"/first_post/:1:0","tags":null,"title":"毕设","uri":"/first_post/"},{"categories":null,"content":"主要的目的呢？ 局限于校内的真正分享 For Master 这里要分为两个板块： 保研的择校和保研的经历分享。 考研的资料和择校及经验的分享。 For Civil Servant 由于公考竞争较为激烈，所以这里应当只开放上岸的经验分享。 For Worker 像OfferShow一样提供一个校内的offer爆料平台。由于可以不用防定位，所以爆出来的料会更加真实。但相反，由于人数的局限，所以平台能提供的信息会较为狭窄。 实习求职经验分享 笔试、面经的分享 市面上的其他产品 offershow: 一款薪资查询的平台，但是发布者需要防止被招聘公司认出。 牛客： 该软件的功能种类多。但其主要的业务范围还是供校招生分享经验。 脉脉 这款软件的服务人群是已经进入职场求职的人。讨论更偏向于职场上发生的事情。 技术选型 Code repository ","date":"2022-11-24","objectID":"/first_post/:1:1","tags":null,"title":"毕设","uri":"/first_post/"},{"categories":null,"content":"移动端 如果能投入使用，那么小程序无疑是较为方便的。本次会考虑在腾讯提供的小程序构建平台或uniapp中选取。 ","date":"2022-11-24","objectID":"/first_post/:1:2","tags":null,"title":"毕设","uri":"/first_post/"},{"categories":null,"content":"后端 我希望将其做成一个微服务。 依托阿里开源的 spirngcloud alibaba 来快速构建 数据库还是采用市面上流行的 Mysql 搜索方面会引入市面上的巨无霸：ElasticSearch Nosql方面也是选择市面上流行的 Redis ","date":"2022-11-24","objectID":"/first_post/:1:3","tags":null,"title":"毕设","uri":"/first_post/"}]